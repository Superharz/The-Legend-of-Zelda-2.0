package Game;

import Inventory.Inventory;
import Events.Event;
import Inventory.Items;
import Moveable.Enemies.Enemie;
import Moveable.Mover;
import Moveable.Player.Player;
import Moveable.Weapons.Arrow;
import Tools.ImagePanel;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JOptionPane;

/**
 * This is the Map-Class which is contained by the Engine
 * The Map keeps track of everything, Spots, Arrows, Enemies, Events 
 * and the Player 
 * @author Florian Harz
 */
public class Map extends ImagePanel implements Moveable.Events, java.io.Serializable {

    public final List<MapChange> listeners = new ArrayList<MapChange>();
    boolean pause = false, first = true;
    Spot[][] spots;
    Point playerPosition = new Point(-1, -1);
    int width, height;
    transient BufferedImage img;
    LinkedList<Enemie> enemies;
    LinkedList<Arrow> arrows;
    int spotWidth;
    String mapName = "Map1";
    transient Thread t;
    private int startX, startY;
    private boolean protection = false;

    /**
     * Creates new form Map
     */
    public Map() {
        this.player = new Player();
        initComponents();
        player.addListener(this);
        enemies = new LinkedList();
        arrows = new LinkedList<Arrow>();
    }

    public Map(Player player) {
        this.player = player;
        initComponents();
        player.addListener(this);
        startX = toSpots(player.getLocation().x);
        startY = toSpots(player.getLocation().y);
        enemies = new LinkedList();
        arrows = new LinkedList<Arrow>();
    }

    public void setMapName(String mapName) {
        this.mapName = mapName;
    }

    public String getMapName() {
        return mapName;
    }

    public void setPlayer(Player player, Point location) {
        this.remove(this.player);
        this.player = player;
        this.add(this.player);
        player.addListener(this);
        player.setBounds(toPixel(location.x), toPixel(location.y),
                player.getIcon().getIconWidth(),
                player.getIcon().getIconHeight());
        startX = location.x;
        startY = location.y;
        if (spots != null) {
            player.setSpots(spots);
        }
        this.validate();
        this.repaint();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {
        this.setLayout(null);
        //player = new Moveable.Player.Player();
        this.add(player);
        //player.setBounds(100, 50, player.getWidth(), player.getHeight());
        this.repaint();

        //enemie1 = new Moveable.Enemies.Enemie();

//        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
//        this.setLayout(layout);
//        layout.setHorizontalGroup(
//            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
//            .addGroup(layout.createSequentialGroup()
//                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
//                    .addGroup(layout.createSequentialGroup()
//                        .addGap(111, 111, 111)
//                        .addComponent(player, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
//                    .addGroup(layout.createSequentialGroup()
//                        .addGap(143, 143, 143)
//                        //.addComponent(enemie1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
//                        ))
//                .addContainerGap(227, Short.MAX_VALUE))
//        );
//        layout.setVerticalGroup(
//            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
//            .addGroup(layout.createSequentialGroup()
//                .addGap(59, 59, 59)
//                .addComponent(player, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
//                .addGap(70, 70, 70)
//                //.addComponent(enemie1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
//                .addContainerGap(139, Short.MAX_VALUE))
//        );
    }// </editor-fold>                        
    // Variables declaration - do not modify                     
    private Moveable.Player.Player player;
    // End of variables declaration                   

    public void setUP(int width, int heights, int playerX, int playerY) {
        this.width = width;
        this.height = heights;
        if (playerX != -1 && playerY != -1) {
            startX = playerX;
            startY = playerY;
        }
        player.setSize(player.getWidth(), player.getWidth());
        spots = new Spot[heights][width];
    }

    public Point getPlayerPosition() {
        return playerPosition;
    }

    public void addSpot(Spot spot, int x, int y) {
        spots[y][x] = spot;
        if (first) {
            this.setSize(width * spots[y][x].image().getWidth(), height * spots[y][x].image().getHeight());
            spotWidth = spot.image().getWidth();
            player.setBounds(toPixel(startX), toPixel(startY), player.getWidth(), player.getWidth());
            first = false;
        }
        player.setUP(spots);
    }

    public void setAllSpots(Spot s) {
        for (int y = 0; y < spots.length; y++) {
            for (int x = 0; x < spots[0].length; x++) {
                addSpot(s.clone(), x, y);
            }
        }
    }

    private boolean updatePlayerPosition() {
        Point oldPosition = playerPosition;
        playerPosition = new Point(toSpots(player.getHotSpot().x), toSpots(player.getHotSpot().y));
        return !oldPosition.equals(playerPosition);
    }

    public Spot getSpot(int x, int y) {
        return spots[y][x];
    }

    public LinkedList<Enemie> getEnemies() {
        return enemies;
    }

    public int getSpotWidth() {
        return spotWidth;
    }

    public void releaseEvents() {
        listeners.clear();
    }

    public Dimension getDimension() {
        return new Dimension(img.getWidth(), img.getHeight());
    }

    public void build() {
        int x = spots[0][0].image().getWidth();
        int y = spots[0][0].image().getHeight();
        img = new BufferedImage(x * width, y * height, BufferedImage.TYPE_INT_ARGB);
        Graphics g = img.getGraphics();
        for (int i = 0; i < spots.length; i++) { //rows
            for (int j = 0; j < spots[i].length; j++) { //colums
                if (spots[i][j] != null) {
                    g.drawImage(spots[i][j].image(), j * x, i * y, this);
                }
            }
            g.drawLine(0, i * y, x * width, i * y);
        }
        for (int i = 0; i < spots[0].length; i++) {
            g.drawLine(i * x, 0, i * x, y * height);
        }
        setBackground(img);
    }

    @Override
    public void attacke(Rectangle r) {
        playerAttack(r);
    }

    public Player getplayer() {
        return player;
    }

    /**
     * X and Y in Pixels
     *
     * @param e
     * @param x
     * @param y
     */
    public Enemie addEnemy(Enemie e, int x, int y) {
        e = e.clone();
        enemies.add(e);
        this.add(e);
        e.addListener(this);
        e.setBounds(x, y, e.getWidth(), e.getWidth());
        e.setUP(spots);
        e.startMove();
        return e;
    }

    /**
     * Point in spots
     *
     * @param e
     * @param p
     */
    public Enemie addEnemy(Enemie e, Point p) {
        return addEnemy(e, toPixel(p.x), toPixel(p.y));
    }

    /**
     * Point in spots
     *
     * @param e
     * @param p
     */
    public void addEnemy(Enemie e, Point p, boolean start) {
        e = addEnemy(e, p);
        if (start) {
            e.startMove();
        }
    }

    public void addEvent(int x, int y, Event evt) {
        evt.addListener(this);
        spots[y][x].addEvent(evt);
    }

    public void addItem(int x, int y, Items item) {
        spots[y][x].additem(item);
        this.add(item);
        item.setBounds(toPixel(x), toPixel(y), item.getIcon().getIconWidth(), item.getIcon().getIconHeight());
        System.out.println("Item added!");
    }

    public Items removeItem(int x, int y) {
        Items j, f = null;
        if (spots[y][x].hasItem()) {
            for (int i = 0; i < spots[y][x].itemLength(); i++) {
                if (i == 0) {
                    f = spots[y][x].pickUp();
                    j = f;
                } else {
                    j = spots[y][x].pickUp();
                }
                this.remove(j);
                if (spots[y][x].hasItem()) {
                    break;
                }
            }
        }
        System.out.println("Item removed!");
        return f;
    }

    public Event removeEvent(int x, int y) {
        LinkedList<Event> events;
        Event evt = null;
        events = spots[y][x].removeEvents();
        if (events != null) {
            evt = events.getLast();
        }
        events = null;
        System.gc();
        System.out.println("Event removed!");
        return evt;
    }

    public Enemie removeEnemie(int x, int y) {
        int X;
        int Y;
        Enemie f = null;
        Enemie e;
        for (int i = 0; i < enemies.size(); i++) {
            e = enemies.get(i);
            X = toSpots(e.getLocation().x);
            Y = toSpots(e.getLocation().y);
            if (X == x && Y == y) {
                f = e;
                this.removeMover(e);
            }
        }
        System.gc();
        System.out.println("Enemie removed!");
        return f;
    }

    public Spot[][] getSpots() {
        return spots;
    }

    @Override
    public synchronized void moved() {
        if (!protection) {
            Rectangle enemieBox;
            Rectangle playerBox = player.getHitBox();
            for (Enemie enemie : enemies) {
                enemieBox = enemie.getHitBox();
                if (enemieBox == null) {
                    System.out.println("Null-enemie");//Shouldn't happen
                } else if (playerBox == null) {
                    System.out.println("Null-playerBox");//Shouldn't happen
                } else if (playerBox.intersects(enemieBox)) {
                    System.out.println("Got Damage, Live left: " + player.getHealth());
                    player.takeDamage(enemie.getStrength());
                    protection = true;
                    protect();
                    return;
                }
            }
        }
    }

    private void protect() {
        Thread t = new Thread() {
            @Override
            public void run() {
                synchronized (this) {
                    try {
                        Thread.sleep(5000);//How long the player is protected
                        protection = false;
                    } catch (Exception ex) {
                        Logger.getLogger(Player.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }
        };
        t.start();
    }

    public synchronized boolean playerAttack(Rectangle r) {
        return playerAttack(r, true, player.getStrength());
    }

    private synchronized boolean playerAttack(Rectangle r, boolean friendly, int strength) {
        Rectangle enemieBox;
        boolean killed = false;
        if (friendly) {
            for (int i = 0; i < enemies.size(); i++) {
                if (enemies.get(i).getLayer() == player.getLayer()) {
                    enemieBox = enemies.get(i).getHitBox();
                    if (r.intersects(enemieBox)) {
                        killed = true;
                        enemies.get(i).takeDamage(strength);
                        return killed;
                    }
                }
            }
            return killed;
        } else {
            if (r.intersects(player.getHitBox())) {
                killed = true;
                player.takeDamage(strength);
            }
            return killed;
        }
    }

    public void move() {
        t = new Thread("Arrow") {
            @Override
            public void run() {
                boolean move = true;
                try {
                    while (move) {
                        Thread.sleep(10);//Time between each move
                        for (int i = 0; i < arrows.size() - 1; i++) {
                            /**
                             * -1, because through the Multi-Thread Sometimes,
                             * the loop tries to access an Arrow which was
                             * removed by an other thread
                             */
                            if (i >= arrows.size()) {
                                System.out.println("TOO big!!!");
                            } else if (!arrows.get(i).move() || playerAttack(arrows.get(i).getHitBox(), arrows.get(i).isFriendly(), arrows.get(i).getDamage())) {
                                removeMover(arrows.get(i));
                                if (arrows.size() <= 0) {
                                    move = false;
                                    break;
                                }
                            }
                            checkForPaused();//To pause the loop if needed
                        }
                    }
                } catch (Exception ex) {
                    Logger.getLogger(Player.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        };
        t.start();
    }

    private void checkForPaused() {
        synchronized (this) {
            while (pause) {
                try {
                    this.wait();
                } catch (Exception e) {
                    System.out.println(e.getMessage());
                }
            }
        }
    }

    public void pauseThread() throws InterruptedException {
        pause = true;
    }

    public void resumeThread() {
        synchronized (this) {
            pause = false;
            this.notify();
        }
    }

    public synchronized void play(boolean play) {
        try {
            if (play) {
                for (int i = 0; i < enemies.size(); i++) {
                    enemies.get(i).resumeThread();
                }
                resumeThread();
            } else {
                for (int i = 0; i < enemies.size(); i++) {
                    enemies.get(i).pauseThread();
                }
                pauseThread();
            }
        } catch (Exception ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public void playerShoot() {
        spawnArrow(true, player.getX() + player.getWidth() / 2, player.getY() + player.getWidth() / 2, player.lastDirection, player.getDamage());
    }

    @Override
    public void spawnArrow(boolean friendly, int x, int y, int direction, int damage) {
        try {
            BufferedImage arrow = null;
            arrow = ImageIO.read(this.getClass().
                    getResource("/Pictures/Arrow" + direction + ".png"));
            Arrow a = new Arrow(x, y, direction, damage, arrow, spots, player.getLayer());
            a.setFrienfly(friendly);
            arrows.addFirst(a);
            this.add(a);
            a.setBounds(x, y, arrow.getWidth(), arrow.getHeight());
            this.repaint();
            if (arrows.size() > 1 && !t.isAlive() || arrows.size() >= 50) {
                this.removeArrows(arrows);
                arrows.addFirst(a); //Tries to avoid the crash of the
                //Arrow Thread
            }
            if (arrows.size() == 1) {//If the Thread is empty it stops it self
                move();//Restarts the Arrow Thread
            }
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    @Override
    public void removeMover(Mover m) {
        if (m instanceof Enemie) {
            this.remove(m);
            enemies.remove(m);
        }
        if (m instanceof Arrow) {
            this.remove(m);
            arrows.remove(m);
        }
        repaint();
    }

    public void removeArrows(LinkedList<Arrow> m) {
        for (int i = 0; i < m.size(); i++) {
            this.remove(m.get(i));
        }
        arrows.clear();
        repaint();
    }

    @Override
    public void heal(int amount) {
        player.heal(amount);
        System.out.println("Got Healed, Live left: " + player.getHealth());
    }

    @Override
    public void teleport(Point destination) {
        player.setLocation(toPixel(destination.x), toPixel(destination.y));
        player.updateHeight();
    }

    public void addListener(MapChange toAdd) {
        listeners.add(toAdd);
    }

    @Override
    public void teleport(Point destination, String mapName) {
        for (MapChange hl : listeners) {
            hl.mapChange(destination, mapName);
        }
    }

    @Override
    public void text(String text) {
        player.stopMoving();
        JOptionPane.showMessageDialog(null, text, "Message", JOptionPane.INFORMATION_MESSAGE, null);
    }

    public int toPixel(int spot) {
        return spot * spotWidth;
    }

    public int toSpots(int pixels) {
        return pixels / spotWidth;
    }

    public Inventory getInventory() {
        return player.getInventory();
    }

    public BufferedImage getImage() {
        return img;
    }

    public void destroy() {
        for (int i = 0; i < spots.length; i++) {
            for (int j = 0; j < spots[i].length; j++) {
                spots[i][j].destroy();
            }
        }
        player.setSpots(null);
        if (listeners != null) {
            listeners.clear();
        }
    }

    @Override
    public void playerMoved() {
        boolean moved = updatePlayerPosition();//True, if the Player's spot changed
        if (moved) {
            while (spots[playerPosition.y][playerPosition.x].hasItem()) {
                Items item = spots[playerPosition.y][playerPosition.x].pickUp();
                player.addItem(item);
                this.remove(item);
                repaint();
                System.out.println("Item picked UP!");
            }
            spots[playerPosition.y][playerPosition.x].callEvents();
        }
    }

    @Override
    public void spawnEnemie(Point p, Enemie e) {
        addEnemy(e, p);
    }

    @Override
    public void spawnItem(Point p, Items item) {
        this.addItem(p.x, p.y, item);
        this.repaint();
    }

    @Override
    public void use(Items item) {
        player.use(item);
    }

    void reUpdate() {
        build();
        requestFocus();
        this.play(true);
        getplayer().getInventory().addEvent();
        for (int i = 0; i < enemies.size(); i++) {
            enemies.get(i).startMove();
        }
        move();
    }
}